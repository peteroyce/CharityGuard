import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  TextField,
  Button,
  Card,
  CardContent,
  Alert,
  InputAdornment,
  Grid,
} from '@mui/material';
import { loadStripe } from '@stripe/stripe-js';
import {
  Elements,
  CardElement,
  useStripe,
  useElements,
} from '@stripe/react-stripe-js';
import { motion } from 'framer-motion';
import { paymentAPI } from '../../services/api';

const stripePromise = loadStripe(process.env.REACT_APP_STRIPE_PUBLISHABLE_KEY!);

interface PaymentFormProps {
  charity: {
    _id: string;
    name: string;
    registrationNumber: string;
  };
  onSuccess: (paymentDetails: any) => void;
}

const PaymentFormInner: React.FC<PaymentFormProps> = ({ charity, onSuccess }) => {
  const stripe = useStripe();
  const elements = useElements();
  
  const [amount, setAmount] = useState<string>('25');
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<string>('');
  const [clientSecret, setClientSecret] = useState<string>('');

  const predefinedAmounts = [10, 25, 50, 100, 250, 500];

  useEffect(() => {
    if (amount && parseFloat(amount) > 0) {
      createPaymentIntent();
    }
  }, [amount]);

  const createPaymentIntent = async () => {
    try {
      const response = await paymentAPI.createPaymentIntent(
        parseFloat(amount) * 100, // Convert to cents
        charity._id
      );
      
      if (response.success) {
        setClientSecret(response.clientSecret);
      }
    } catch (error) {
      console.error('Failed to create payment intent:', error);
    }
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    
    if (!stripe || !elements || !clientSecret) return;
    
    setIsProcessing(true);
    setError('');

    const cardElement = elements.getElement(CardElement);
    if (!cardElement) return;

    try {
      const { error: stripeError, paymentIntent } = await stripe.confirmCardPayment(
        clientSecret,
        {
          payment_method: {
            card: cardElement,
          },
        }
      );

      if (stripeError) {
        setError(stripeError.message || 'Payment failed');
      } else if (paymentIntent?.status === 'succeeded') {
        // Confirm with backend
        await paymentAPI.confirmPayment(paymentIntent.id);
        
        onSuccess({
          paymentIntentId: paymentIntent.id,
          amount: parseFloat(amount),
          charity: charity.name,
        });
      }
    } catch (error) {
      setError('Payment processing failed. Please try again.');
    } finally {
      setIsProcessing(false);
    }
  };

  const cardElementOptions = {
    style: {
      base: {
        fontSize: '16px',
        color: '#1C1C1E',
        '::placeholder': {
          color: '#8E8E93',
        },
      },
    },
  };

  return (
    <Card sx={{ maxWidth: 600, mx: 'auto', mt: 4 }}>
      <CardContent sx={{ p: 4 }}>
        <Typography variant="h5" sx={{ mb: 3, fontWeight: 600 }}>
          Complete Your Donation
        </Typography>
        
        <Box sx={{ mb: 3, p: 2, backgroundColor: '#F2F2F7', borderRadius: 2 }}>
          <Typography variant="subtitle1" fontWeight={600}>
            {charity.name}
          </Typography>
          <Typography variant="body2" color="text.secondary">
            EIN: {charity.registrationNumber}
          </Typography>
        </Box>

        <form onSubmit={handleSubmit}>
          {/* Amount Selection */}
          <Typography variant="h6" sx={{ mb: 2 }}>
            Donation Amount
          </Typography>
          
          <Grid container spacing={2} sx={{ mb: 3 }}>
            {predefinedAmounts.map((presetAmount) => (
              <Grid item xs={4} sm={2} key={presetAmount}>
                <Button
                  variant={amount === presetAmount.toString() ? 'contained' : 'outlined'}
                  fullWidth
                  onClick={() => setAmount(presetAmount.toString())}
                  sx={{ borderRadius: 2 }}
                >
                  ${presetAmount}
                </Button>
              </Grid>
            ))}
          </Grid>

          <TextField
            label="Custom Amount"
            value={amount}
            onChange={(e) => setAmount(e.target.value)}
            type="number"
            fullWidth
            InputProps={{
              startAdornment: <InputAdornment position="start">$</InputAdornment>,
            }}
            sx={{ mb: 3 }}
          />

          {/* Card Details */}
          <Typography variant="h6" sx={{ mb: 2 }}>
            Payment Details
          </Typography>
          
          <Box
            sx={{
              p: 2,
              border: '2px solid #E5E5EA',
              borderRadius: 2,
              mb: 3,
              '&:focus-within': {
                borderColor: '#007AFF',
              },
            }}
          >
            <CardElement options={cardElementOptions} />
          </Box>

          {error && (
            <Alert severity="error" sx={{ mb: 3 }}>
              {error}
            </Alert>
          )}

          <motion.div whileHover={{ scale: 1.02 }} whileTap={{ scale: 0.98 }}>
            <Button
              type="submit"
              variant="contained"
              fullWidth
              size="large"
              disabled={!stripe || isProcessing || !amount || parseFloat(amount) <= 0}
              sx={{
                py: 2,
                fontSize: '1.1rem',
                fontWeight: 600,
                borderRadius: 3,
              }}
            >
              {isProcessing ? 'Processing...' : `Donate $${amount}`}
            </Button>
          </motion.div>
        </form>

        <Box sx={{ mt: 3, textAlign: 'center' }}>
          <Typography variant="caption" color="text.secondary">
            ðŸ”’ Payments are secure and encrypted
          </Typography>
        </Box>
      </CardContent>
    </Card>
  );
};

export const PaymentForm: React.FC<PaymentFormProps> = (props) => {
  return (
    <Elements stripe={stripePromise}>
      <PaymentFormInner {...props} />
    </Elements>
  );
};